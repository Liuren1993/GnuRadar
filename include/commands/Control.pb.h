// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#ifndef PROTOBUF_Control_2eproto__INCLUDED
#define PROTOBUF_Control_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace gnuradar {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Control_2eproto();
void protobuf_AssignDesc_Control_2eproto();
void protobuf_ShutdownFile_Control_2eproto();

class ControlMessage;
class File;
class Channel;
class Window;
class RadarParameters;

// ===================================================================

class ControlMessage : public ::google::protobuf::Message {
 public:
  ControlMessage();
  virtual ~ControlMessage();

  ControlMessage(const ControlMessage& from);

  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlMessage& default_instance();

  void Swap(ControlMessage* other);

  // implements Message ----------------------------------------------

  ControlMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlMessage& from);
  void MergeFrom(const ControlMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .gnuradar.File file = 2;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 2;
  inline const ::gnuradar::File& file() const;
  inline ::gnuradar::File* mutable_file();
  inline ::gnuradar::File* release_file();
  inline void set_allocated_file(::gnuradar::File* file);

  // @@protoc_insertion_point(class_scope:gnuradar.ControlMessage)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_file();
  inline void clear_has_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::gnuradar::File* file_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static ControlMessage* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required float sampleRate = 2;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 2;
  inline float samplerate() const;
  inline void set_samplerate(float value);

  // required int32 decimation = 3;
  inline bool has_decimation() const;
  inline void clear_decimation();
  static const int kDecimationFieldNumber = 3;
  inline ::google::protobuf::int32 decimation() const;
  inline void set_decimation(::google::protobuf::int32 value);

  // required int32 numChannels = 4;
  inline bool has_numchannels() const;
  inline void clear_numchannels();
  static const int kNumChannelsFieldNumber = 4;
  inline ::google::protobuf::int32 numchannels() const;
  inline void set_numchannels(::google::protobuf::int32 value);

  // required float bandwidth = 5;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 5;
  inline float bandwidth() const;
  inline void set_bandwidth(float value);

  // required string bandwidthUnits = 6;
  inline bool has_bandwidthunits() const;
  inline void clear_bandwidthunits();
  static const int kBandwidthUnitsFieldNumber = 6;
  inline const ::std::string& bandwidthunits() const;
  inline void set_bandwidthunits(const ::std::string& value);
  inline void set_bandwidthunits(const char* value);
  inline void set_bandwidthunits(const char* value, size_t size);
  inline ::std::string* mutable_bandwidthunits();
  inline ::std::string* release_bandwidthunits();
  inline void set_allocated_bandwidthunits(::std::string* bandwidthunits);

  // required int32 numWindows = 7;
  inline bool has_numwindows() const;
  inline void clear_numwindows();
  static const int kNumWindowsFieldNumber = 7;
  inline ::google::protobuf::int32 numwindows() const;
  inline void set_numwindows(::google::protobuf::int32 value);

  // required float pri = 8;
  inline bool has_pri() const;
  inline void clear_pri();
  static const int kPriFieldNumber = 8;
  inline float pri() const;
  inline void set_pri(float value);

  // required string priUnits = 9;
  inline bool has_priunits() const;
  inline void clear_priunits();
  static const int kPriUnitsFieldNumber = 9;
  inline const ::std::string& priunits() const;
  inline void set_priunits(const ::std::string& value);
  inline void set_priunits(const char* value);
  inline void set_priunits(const char* value, size_t size);
  inline ::std::string* mutable_priunits();
  inline ::std::string* release_priunits();
  inline void set_allocated_priunits(::std::string* priunits);

  // required float txCarrier = 10;
  inline bool has_txcarrier() const;
  inline void clear_txcarrier();
  static const int kTxCarrierFieldNumber = 10;
  inline float txcarrier() const;
  inline void set_txcarrier(float value);

  // required string organization = 11;
  inline bool has_organization() const;
  inline void clear_organization();
  static const int kOrganizationFieldNumber = 11;
  inline const ::std::string& organization() const;
  inline void set_organization(const ::std::string& value);
  inline void set_organization(const char* value);
  inline void set_organization(const char* value, size_t size);
  inline ::std::string* mutable_organization();
  inline ::std::string* release_organization();
  inline void set_allocated_organization(::std::string* organization);

  // required string site = 12;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 12;
  inline const ::std::string& site() const;
  inline void set_site(const ::std::string& value);
  inline void set_site(const char* value);
  inline void set_site(const char* value, size_t size);
  inline ::std::string* mutable_site();
  inline ::std::string* release_site();
  inline void set_allocated_site(::std::string* site);

  // required string user = 13;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 13;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string radar = 14;
  inline bool has_radar() const;
  inline void clear_radar();
  static const int kRadarFieldNumber = 14;
  inline const ::std::string& radar() const;
  inline void set_radar(const ::std::string& value);
  inline void set_radar(const char* value);
  inline void set_radar(const char* value, size_t size);
  inline ::std::string* mutable_radar();
  inline ::std::string* release_radar();
  inline void set_allocated_radar(::std::string* radar);

  // required string receiver = 15;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 15;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // required string fpgaImage = 16;
  inline bool has_fpgaimage() const;
  inline void clear_fpgaimage();
  static const int kFpgaImageFieldNumber = 16;
  inline const ::std::string& fpgaimage() const;
  inline void set_fpgaimage(const ::std::string& value);
  inline void set_fpgaimage(const char* value);
  inline void set_fpgaimage(const char* value, size_t size);
  inline ::std::string* mutable_fpgaimage();
  inline ::std::string* release_fpgaimage();
  inline void set_allocated_fpgaimage(::std::string* fpgaimage);

  // required string baseFileName = 17;
  inline bool has_basefilename() const;
  inline void clear_basefilename();
  static const int kBaseFileNameFieldNumber = 17;
  inline const ::std::string& basefilename() const;
  inline void set_basefilename(const ::std::string& value);
  inline void set_basefilename(const char* value);
  inline void set_basefilename(const char* value, size_t size);
  inline ::std::string* mutable_basefilename();
  inline ::std::string* release_basefilename();
  inline void set_allocated_basefilename(::std::string* basefilename);

  // optional float outputRate = 18;
  inline bool has_outputrate() const;
  inline void clear_outputrate();
  static const int kOutputRateFieldNumber = 18;
  inline float outputrate() const;
  inline void set_outputrate(float value);

  // repeated .gnuradar.Channel channel = 19;
  inline int channel_size() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 19;
  inline const ::gnuradar::Channel& channel(int index) const;
  inline ::gnuradar::Channel* mutable_channel(int index);
  inline ::gnuradar::Channel* add_channel();
  inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >&
      channel() const;
  inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >*
      mutable_channel();

  // repeated .gnuradar.Window window = 20;
  inline int window_size() const;
  inline void clear_window();
  static const int kWindowFieldNumber = 20;
  inline const ::gnuradar::Window& window(int index) const;
  inline ::gnuradar::Window* mutable_window(int index);
  inline ::gnuradar::Window* add_window();
  inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >&
      window() const;
  inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >*
      mutable_window();

  // optional .gnuradar.RadarParameters radarParameters = 21;
  inline bool has_radarparameters() const;
  inline void clear_radarparameters();
  static const int kRadarParametersFieldNumber = 21;
  inline const ::gnuradar::RadarParameters& radarparameters() const;
  inline ::gnuradar::RadarParameters* mutable_radarparameters();
  inline ::gnuradar::RadarParameters* release_radarparameters();
  inline void set_allocated_radarparameters(::gnuradar::RadarParameters* radarparameters);

  // @@protoc_insertion_point(class_scope:gnuradar.File)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_decimation();
  inline void clear_has_decimation();
  inline void set_has_numchannels();
  inline void clear_has_numchannels();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_bandwidthunits();
  inline void clear_has_bandwidthunits();
  inline void set_has_numwindows();
  inline void clear_has_numwindows();
  inline void set_has_pri();
  inline void clear_has_pri();
  inline void set_has_priunits();
  inline void clear_has_priunits();
  inline void set_has_txcarrier();
  inline void clear_has_txcarrier();
  inline void set_has_organization();
  inline void clear_has_organization();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_radar();
  inline void clear_has_radar();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_fpgaimage();
  inline void clear_has_fpgaimage();
  inline void set_has_basefilename();
  inline void clear_has_basefilename();
  inline void set_has_outputrate();
  inline void clear_has_outputrate();
  inline void set_has_radarparameters();
  inline void clear_has_radarparameters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  float samplerate_;
  ::google::protobuf::int32 decimation_;
  ::google::protobuf::int32 numchannels_;
  float bandwidth_;
  ::std::string* bandwidthunits_;
  ::google::protobuf::int32 numwindows_;
  float pri_;
  ::std::string* priunits_;
  ::std::string* organization_;
  ::std::string* site_;
  ::std::string* user_;
  ::std::string* radar_;
  float txcarrier_;
  float outputrate_;
  ::std::string* receiver_;
  ::std::string* fpgaimage_;
  ::std::string* basefilename_;
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel > channel_;
  ::google::protobuf::RepeatedPtrField< ::gnuradar::Window > window_;
  ::gnuradar::RadarParameters* radarparameters_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  void Swap(Channel* other);

  // implements Message ----------------------------------------------

  Channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float frequency = 1;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  inline float frequency() const;
  inline void set_frequency(float value);

  // required string frequencyUnits = 2;
  inline bool has_frequencyunits() const;
  inline void clear_frequencyunits();
  static const int kFrequencyUnitsFieldNumber = 2;
  inline const ::std::string& frequencyunits() const;
  inline void set_frequencyunits(const ::std::string& value);
  inline void set_frequencyunits(const char* value);
  inline void set_frequencyunits(const char* value, size_t size);
  inline ::std::string* mutable_frequencyunits();
  inline ::std::string* release_frequencyunits();
  inline void set_allocated_frequencyunits(::std::string* frequencyunits);

  // required float phase = 3;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 3;
  inline float phase() const;
  inline void set_phase(float value);

  // required string phaseUnits = 4;
  inline bool has_phaseunits() const;
  inline void clear_phaseunits();
  static const int kPhaseUnitsFieldNumber = 4;
  inline const ::std::string& phaseunits() const;
  inline void set_phaseunits(const ::std::string& value);
  inline void set_phaseunits(const char* value);
  inline void set_phaseunits(const char* value, size_t size);
  inline ::std::string* mutable_phaseunits();
  inline ::std::string* release_phaseunits();
  inline void set_allocated_phaseunits(::std::string* phaseunits);

  // @@protoc_insertion_point(class_scope:gnuradar.Channel)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_frequencyunits();
  inline void clear_has_frequencyunits();
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_phaseunits();
  inline void clear_has_phaseunits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* frequencyunits_;
  float frequency_;
  float phase_;
  ::std::string* phaseunits_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static Channel* default_instance_;
};
// -------------------------------------------------------------------

class Window : public ::google::protobuf::Message {
 public:
  Window();
  virtual ~Window();

  Window(const Window& from);

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Window& default_instance();

  void Swap(Window* other);

  // implements Message ----------------------------------------------

  Window* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Window& from);
  void MergeFrom(const Window& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline float start() const;
  inline void set_start(float value);

  // required float stop = 3;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 3;
  inline float stop() const;
  inline void set_stop(float value);

  // optional float width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline float width() const;
  inline void set_width(float value);

  // required string units = 5;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 5;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // @@protoc_insertion_point(class_scope:gnuradar.Window)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_units();
  inline void clear_has_units();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  float start_;
  float stop_;
  ::std::string* units_;
  float width_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static Window* default_instance_;
};
// -------------------------------------------------------------------

class RadarParameters : public ::google::protobuf::Message {
 public:
  RadarParameters();
  virtual ~RadarParameters();

  RadarParameters(const RadarParameters& from);

  inline RadarParameters& operator=(const RadarParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarParameters& default_instance();

  void Swap(RadarParameters* other);

  // implements Message ----------------------------------------------

  RadarParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadarParameters& from);
  void MergeFrom(const RadarParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 samplesPerPri = 1;
  inline bool has_samplesperpri() const;
  inline void clear_samplesperpri();
  static const int kSamplesPerPriFieldNumber = 1;
  inline ::google::protobuf::int32 samplesperpri() const;
  inline void set_samplesperpri(::google::protobuf::int32 value);

  // required int32 samplesPerBuffer = 2;
  inline bool has_samplesperbuffer() const;
  inline void clear_samplesperbuffer();
  static const int kSamplesPerBufferFieldNumber = 2;
  inline ::google::protobuf::int32 samplesperbuffer() const;
  inline void set_samplesperbuffer(::google::protobuf::int32 value);

  // required int32 bytesPerBuffer = 3;
  inline bool has_bytesperbuffer() const;
  inline void clear_bytesperbuffer();
  static const int kBytesPerBufferFieldNumber = 3;
  inline ::google::protobuf::int32 bytesperbuffer() const;
  inline void set_bytesperbuffer(::google::protobuf::int32 value);

  // required float bytesPerSecond = 4;
  inline bool has_bytespersecond() const;
  inline void clear_bytespersecond();
  static const int kBytesPerSecondFieldNumber = 4;
  inline float bytespersecond() const;
  inline void set_bytespersecond(float value);

  // required float pri = 5;
  inline bool has_pri() const;
  inline void clear_pri();
  static const int kPriFieldNumber = 5;
  inline float pri() const;
  inline void set_pri(float value);

  // required float prf = 6;
  inline bool has_prf() const;
  inline void clear_prf();
  static const int kPrfFieldNumber = 6;
  inline float prf() const;
  inline void set_prf(float value);

  // required int32 prisPerBuffer = 7;
  inline bool has_prisperbuffer() const;
  inline void clear_prisperbuffer();
  static const int kPrisPerBufferFieldNumber = 7;
  inline ::google::protobuf::int32 prisperbuffer() const;
  inline void set_prisperbuffer(::google::protobuf::int32 value);

  // required int32 bytesPerSample = 8;
  inline bool has_bytespersample() const;
  inline void clear_bytespersample();
  static const int kBytesPerSampleFieldNumber = 8;
  inline ::google::protobuf::int32 bytespersample() const;
  inline void set_bytespersample(::google::protobuf::int32 value);

  // required float secondsPerBuffer = 9;
  inline bool has_secondsperbuffer() const;
  inline void clear_secondsperbuffer();
  static const int kSecondsPerBufferFieldNumber = 9;
  inline float secondsperbuffer() const;
  inline void set_secondsperbuffer(float value);

  // @@protoc_insertion_point(class_scope:gnuradar.RadarParameters)
 private:
  inline void set_has_samplesperpri();
  inline void clear_has_samplesperpri();
  inline void set_has_samplesperbuffer();
  inline void clear_has_samplesperbuffer();
  inline void set_has_bytesperbuffer();
  inline void clear_has_bytesperbuffer();
  inline void set_has_bytespersecond();
  inline void clear_has_bytespersecond();
  inline void set_has_pri();
  inline void clear_has_pri();
  inline void set_has_prf();
  inline void clear_has_prf();
  inline void set_has_prisperbuffer();
  inline void clear_has_prisperbuffer();
  inline void set_has_bytespersample();
  inline void clear_has_bytespersample();
  inline void set_has_secondsperbuffer();
  inline void clear_has_secondsperbuffer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 samplesperpri_;
  ::google::protobuf::int32 samplesperbuffer_;
  ::google::protobuf::int32 bytesperbuffer_;
  float bytespersecond_;
  float pri_;
  float prf_;
  ::google::protobuf::int32 prisperbuffer_;
  ::google::protobuf::int32 bytespersample_;
  float secondsperbuffer_;
  friend void  protobuf_AddDesc_Control_2eproto();
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static RadarParameters* default_instance_;
};
// ===================================================================


// ===================================================================

// ControlMessage

// required string name = 1;
inline bool ControlMessage::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlMessage::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ControlMessage::name() const {
  // @@protoc_insertion_point(field_get:gnuradar.ControlMessage.name)
  return *name_;
}
inline void ControlMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.ControlMessage.name)
}
inline void ControlMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.ControlMessage.name)
}
inline void ControlMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.ControlMessage.name)
}
inline ::std::string* ControlMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.ControlMessage.name)
  return name_;
}
inline ::std::string* ControlMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ControlMessage::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.ControlMessage.name)
}

// optional .gnuradar.File file = 2;
inline bool ControlMessage::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlMessage::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlMessage::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlMessage::clear_file() {
  if (file_ != NULL) file_->::gnuradar::File::Clear();
  clear_has_file();
}
inline const ::gnuradar::File& ControlMessage::file() const {
  // @@protoc_insertion_point(field_get:gnuradar.ControlMessage.file)
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::gnuradar::File* ControlMessage::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::gnuradar::File;
  // @@protoc_insertion_point(field_mutable:gnuradar.ControlMessage.file)
  return file_;
}
inline ::gnuradar::File* ControlMessage::release_file() {
  clear_has_file();
  ::gnuradar::File* temp = file_;
  file_ = NULL;
  return temp;
}
inline void ControlMessage::set_allocated_file(::gnuradar::File* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.ControlMessage.file)
}

// -------------------------------------------------------------------

// File

// required string version = 1;
inline bool File::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& File::version() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.version)
  return *version_;
}
inline void File::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.version)
}
inline void File::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.version)
}
inline void File::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.version)
}
inline ::std::string* File::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.version)
  return version_;
}
inline ::std::string* File::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.version)
}

// required float sampleRate = 2;
inline bool File::has_samplerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_samplerate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline float File::samplerate() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.sampleRate)
  return samplerate_;
}
inline void File::set_samplerate(float value) {
  set_has_samplerate();
  samplerate_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.sampleRate)
}

// required int32 decimation = 3;
inline bool File::has_decimation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_decimation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_decimation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_decimation() {
  decimation_ = 0;
  clear_has_decimation();
}
inline ::google::protobuf::int32 File::decimation() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.decimation)
  return decimation_;
}
inline void File::set_decimation(::google::protobuf::int32 value) {
  set_has_decimation();
  decimation_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.decimation)
}

// required int32 numChannels = 4;
inline bool File::has_numchannels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_numchannels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_numchannels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_numchannels() {
  numchannels_ = 0;
  clear_has_numchannels();
}
inline ::google::protobuf::int32 File::numchannels() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.numChannels)
  return numchannels_;
}
inline void File::set_numchannels(::google::protobuf::int32 value) {
  set_has_numchannels();
  numchannels_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.numChannels)
}

// required float bandwidth = 5;
inline bool File::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void File::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void File::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void File::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline float File::bandwidth() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.bandwidth)
  return bandwidth_;
}
inline void File::set_bandwidth(float value) {
  set_has_bandwidth();
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.bandwidth)
}

// required string bandwidthUnits = 6;
inline bool File::has_bandwidthunits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void File::set_has_bandwidthunits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void File::clear_has_bandwidthunits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void File::clear_bandwidthunits() {
  if (bandwidthunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bandwidthunits_->clear();
  }
  clear_has_bandwidthunits();
}
inline const ::std::string& File::bandwidthunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.bandwidthUnits)
  return *bandwidthunits_;
}
inline void File::set_bandwidthunits(const ::std::string& value) {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bandwidthunits_ = new ::std::string;
  }
  bandwidthunits_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.bandwidthUnits)
}
inline void File::set_bandwidthunits(const char* value) {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bandwidthunits_ = new ::std::string;
  }
  bandwidthunits_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.bandwidthUnits)
}
inline void File::set_bandwidthunits(const char* value, size_t size) {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bandwidthunits_ = new ::std::string;
  }
  bandwidthunits_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.bandwidthUnits)
}
inline ::std::string* File::mutable_bandwidthunits() {
  set_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bandwidthunits_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.bandwidthUnits)
  return bandwidthunits_;
}
inline ::std::string* File::release_bandwidthunits() {
  clear_has_bandwidthunits();
  if (bandwidthunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bandwidthunits_;
    bandwidthunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_bandwidthunits(::std::string* bandwidthunits) {
  if (bandwidthunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bandwidthunits_;
  }
  if (bandwidthunits) {
    set_has_bandwidthunits();
    bandwidthunits_ = bandwidthunits;
  } else {
    clear_has_bandwidthunits();
    bandwidthunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.bandwidthUnits)
}

// required int32 numWindows = 7;
inline bool File::has_numwindows() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void File::set_has_numwindows() {
  _has_bits_[0] |= 0x00000040u;
}
inline void File::clear_has_numwindows() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void File::clear_numwindows() {
  numwindows_ = 0;
  clear_has_numwindows();
}
inline ::google::protobuf::int32 File::numwindows() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.numWindows)
  return numwindows_;
}
inline void File::set_numwindows(::google::protobuf::int32 value) {
  set_has_numwindows();
  numwindows_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.numWindows)
}

// required float pri = 8;
inline bool File::has_pri() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void File::set_has_pri() {
  _has_bits_[0] |= 0x00000080u;
}
inline void File::clear_has_pri() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void File::clear_pri() {
  pri_ = 0;
  clear_has_pri();
}
inline float File::pri() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.pri)
  return pri_;
}
inline void File::set_pri(float value) {
  set_has_pri();
  pri_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.pri)
}

// required string priUnits = 9;
inline bool File::has_priunits() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void File::set_has_priunits() {
  _has_bits_[0] |= 0x00000100u;
}
inline void File::clear_has_priunits() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void File::clear_priunits() {
  if (priunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priunits_->clear();
  }
  clear_has_priunits();
}
inline const ::std::string& File::priunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.priUnits)
  return *priunits_;
}
inline void File::set_priunits(const ::std::string& value) {
  set_has_priunits();
  if (priunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priunits_ = new ::std::string;
  }
  priunits_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.priUnits)
}
inline void File::set_priunits(const char* value) {
  set_has_priunits();
  if (priunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priunits_ = new ::std::string;
  }
  priunits_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.priUnits)
}
inline void File::set_priunits(const char* value, size_t size) {
  set_has_priunits();
  if (priunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priunits_ = new ::std::string;
  }
  priunits_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.priUnits)
}
inline ::std::string* File::mutable_priunits() {
  set_has_priunits();
  if (priunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priunits_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.priUnits)
  return priunits_;
}
inline ::std::string* File::release_priunits() {
  clear_has_priunits();
  if (priunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = priunits_;
    priunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_priunits(::std::string* priunits) {
  if (priunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete priunits_;
  }
  if (priunits) {
    set_has_priunits();
    priunits_ = priunits;
  } else {
    clear_has_priunits();
    priunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.priUnits)
}

// required float txCarrier = 10;
inline bool File::has_txcarrier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void File::set_has_txcarrier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void File::clear_has_txcarrier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void File::clear_txcarrier() {
  txcarrier_ = 0;
  clear_has_txcarrier();
}
inline float File::txcarrier() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.txCarrier)
  return txcarrier_;
}
inline void File::set_txcarrier(float value) {
  set_has_txcarrier();
  txcarrier_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.txCarrier)
}

// required string organization = 11;
inline bool File::has_organization() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void File::set_has_organization() {
  _has_bits_[0] |= 0x00000400u;
}
inline void File::clear_has_organization() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void File::clear_organization() {
  if (organization_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    organization_->clear();
  }
  clear_has_organization();
}
inline const ::std::string& File::organization() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.organization)
  return *organization_;
}
inline void File::set_organization(const ::std::string& value) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    organization_ = new ::std::string;
  }
  organization_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.organization)
}
inline void File::set_organization(const char* value) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    organization_ = new ::std::string;
  }
  organization_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.organization)
}
inline void File::set_organization(const char* value, size_t size) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    organization_ = new ::std::string;
  }
  organization_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.organization)
}
inline ::std::string* File::mutable_organization() {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    organization_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.organization)
  return organization_;
}
inline ::std::string* File::release_organization() {
  clear_has_organization();
  if (organization_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = organization_;
    organization_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_organization(::std::string* organization) {
  if (organization_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete organization_;
  }
  if (organization) {
    set_has_organization();
    organization_ = organization;
  } else {
    clear_has_organization();
    organization_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.organization)
}

// required string site = 12;
inline bool File::has_site() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void File::set_has_site() {
  _has_bits_[0] |= 0x00000800u;
}
inline void File::clear_has_site() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void File::clear_site() {
  if (site_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_->clear();
  }
  clear_has_site();
}
inline const ::std::string& File::site() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.site)
  return *site_;
}
inline void File::set_site(const ::std::string& value) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_ = new ::std::string;
  }
  site_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.site)
}
inline void File::set_site(const char* value) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_ = new ::std::string;
  }
  site_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.site)
}
inline void File::set_site(const char* value, size_t size) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_ = new ::std::string;
  }
  site_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.site)
}
inline ::std::string* File::mutable_site() {
  set_has_site();
  if (site_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    site_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.site)
  return site_;
}
inline ::std::string* File::release_site() {
  clear_has_site();
  if (site_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = site_;
    site_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_site(::std::string* site) {
  if (site_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete site_;
  }
  if (site) {
    set_has_site();
    site_ = site;
  } else {
    clear_has_site();
    site_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.site)
}

// required string user = 13;
inline bool File::has_user() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void File::set_has_user() {
  _has_bits_[0] |= 0x00001000u;
}
inline void File::clear_has_user() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void File::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& File::user() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.user)
  return *user_;
}
inline void File::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.user)
}
inline void File::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.user)
}
inline void File::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.user)
}
inline ::std::string* File::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.user)
  return user_;
}
inline ::std::string* File::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.user)
}

// required string radar = 14;
inline bool File::has_radar() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void File::set_has_radar() {
  _has_bits_[0] |= 0x00002000u;
}
inline void File::clear_has_radar() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void File::clear_radar() {
  if (radar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    radar_->clear();
  }
  clear_has_radar();
}
inline const ::std::string& File::radar() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.radar)
  return *radar_;
}
inline void File::set_radar(const ::std::string& value) {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    radar_ = new ::std::string;
  }
  radar_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.radar)
}
inline void File::set_radar(const char* value) {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    radar_ = new ::std::string;
  }
  radar_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.radar)
}
inline void File::set_radar(const char* value, size_t size) {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    radar_ = new ::std::string;
  }
  radar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.radar)
}
inline ::std::string* File::mutable_radar() {
  set_has_radar();
  if (radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    radar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.radar)
  return radar_;
}
inline ::std::string* File::release_radar() {
  clear_has_radar();
  if (radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = radar_;
    radar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_radar(::std::string* radar) {
  if (radar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete radar_;
  }
  if (radar) {
    set_has_radar();
    radar_ = radar;
  } else {
    clear_has_radar();
    radar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.radar)
}

// required string receiver = 15;
inline bool File::has_receiver() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void File::set_has_receiver() {
  _has_bits_[0] |= 0x00004000u;
}
inline void File::clear_has_receiver() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void File::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& File::receiver() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.receiver)
  return *receiver_;
}
inline void File::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.receiver)
}
inline void File::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.receiver)
}
inline void File::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.receiver)
}
inline ::std::string* File::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.receiver)
  return receiver_;
}
inline ::std::string* File::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.receiver)
}

// required string fpgaImage = 16;
inline bool File::has_fpgaimage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void File::set_has_fpgaimage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void File::clear_has_fpgaimage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void File::clear_fpgaimage() {
  if (fpgaimage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fpgaimage_->clear();
  }
  clear_has_fpgaimage();
}
inline const ::std::string& File::fpgaimage() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.fpgaImage)
  return *fpgaimage_;
}
inline void File::set_fpgaimage(const ::std::string& value) {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fpgaimage_ = new ::std::string;
  }
  fpgaimage_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.fpgaImage)
}
inline void File::set_fpgaimage(const char* value) {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fpgaimage_ = new ::std::string;
  }
  fpgaimage_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.fpgaImage)
}
inline void File::set_fpgaimage(const char* value, size_t size) {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fpgaimage_ = new ::std::string;
  }
  fpgaimage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.fpgaImage)
}
inline ::std::string* File::mutable_fpgaimage() {
  set_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fpgaimage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.fpgaImage)
  return fpgaimage_;
}
inline ::std::string* File::release_fpgaimage() {
  clear_has_fpgaimage();
  if (fpgaimage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fpgaimage_;
    fpgaimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_fpgaimage(::std::string* fpgaimage) {
  if (fpgaimage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fpgaimage_;
  }
  if (fpgaimage) {
    set_has_fpgaimage();
    fpgaimage_ = fpgaimage;
  } else {
    clear_has_fpgaimage();
    fpgaimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.fpgaImage)
}

// required string baseFileName = 17;
inline bool File::has_basefilename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void File::set_has_basefilename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void File::clear_has_basefilename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void File::clear_basefilename() {
  if (basefilename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basefilename_->clear();
  }
  clear_has_basefilename();
}
inline const ::std::string& File::basefilename() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.baseFileName)
  return *basefilename_;
}
inline void File::set_basefilename(const ::std::string& value) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.File.baseFileName)
}
inline void File::set_basefilename(const char* value) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.File.baseFileName)
}
inline void File::set_basefilename(const char* value, size_t size) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.File.baseFileName)
}
inline ::std::string* File::mutable_basefilename() {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basefilename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.File.baseFileName)
  return basefilename_;
}
inline ::std::string* File::release_basefilename() {
  clear_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basefilename_;
    basefilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_basefilename(::std::string* basefilename) {
  if (basefilename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basefilename_;
  }
  if (basefilename) {
    set_has_basefilename();
    basefilename_ = basefilename;
  } else {
    clear_has_basefilename();
    basefilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.baseFileName)
}

// optional float outputRate = 18;
inline bool File::has_outputrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void File::set_has_outputrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void File::clear_has_outputrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void File::clear_outputrate() {
  outputrate_ = 0;
  clear_has_outputrate();
}
inline float File::outputrate() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.outputRate)
  return outputrate_;
}
inline void File::set_outputrate(float value) {
  set_has_outputrate();
  outputrate_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.File.outputRate)
}

// repeated .gnuradar.Channel channel = 19;
inline int File::channel_size() const {
  return channel_.size();
}
inline void File::clear_channel() {
  channel_.Clear();
}
inline const ::gnuradar::Channel& File::channel(int index) const {
  // @@protoc_insertion_point(field_get:gnuradar.File.channel)
  return channel_.Get(index);
}
inline ::gnuradar::Channel* File::mutable_channel(int index) {
  // @@protoc_insertion_point(field_mutable:gnuradar.File.channel)
  return channel_.Mutable(index);
}
inline ::gnuradar::Channel* File::add_channel() {
  // @@protoc_insertion_point(field_add:gnuradar.File.channel)
  return channel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >&
File::channel() const {
  // @@protoc_insertion_point(field_list:gnuradar.File.channel)
  return channel_;
}
inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Channel >*
File::mutable_channel() {
  // @@protoc_insertion_point(field_mutable_list:gnuradar.File.channel)
  return &channel_;
}

// repeated .gnuradar.Window window = 20;
inline int File::window_size() const {
  return window_.size();
}
inline void File::clear_window() {
  window_.Clear();
}
inline const ::gnuradar::Window& File::window(int index) const {
  // @@protoc_insertion_point(field_get:gnuradar.File.window)
  return window_.Get(index);
}
inline ::gnuradar::Window* File::mutable_window(int index) {
  // @@protoc_insertion_point(field_mutable:gnuradar.File.window)
  return window_.Mutable(index);
}
inline ::gnuradar::Window* File::add_window() {
  // @@protoc_insertion_point(field_add:gnuradar.File.window)
  return window_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >&
File::window() const {
  // @@protoc_insertion_point(field_list:gnuradar.File.window)
  return window_;
}
inline ::google::protobuf::RepeatedPtrField< ::gnuradar::Window >*
File::mutable_window() {
  // @@protoc_insertion_point(field_mutable_list:gnuradar.File.window)
  return &window_;
}

// optional .gnuradar.RadarParameters radarParameters = 21;
inline bool File::has_radarparameters() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void File::set_has_radarparameters() {
  _has_bits_[0] |= 0x00100000u;
}
inline void File::clear_has_radarparameters() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void File::clear_radarparameters() {
  if (radarparameters_ != NULL) radarparameters_->::gnuradar::RadarParameters::Clear();
  clear_has_radarparameters();
}
inline const ::gnuradar::RadarParameters& File::radarparameters() const {
  // @@protoc_insertion_point(field_get:gnuradar.File.radarParameters)
  return radarparameters_ != NULL ? *radarparameters_ : *default_instance_->radarparameters_;
}
inline ::gnuradar::RadarParameters* File::mutable_radarparameters() {
  set_has_radarparameters();
  if (radarparameters_ == NULL) radarparameters_ = new ::gnuradar::RadarParameters;
  // @@protoc_insertion_point(field_mutable:gnuradar.File.radarParameters)
  return radarparameters_;
}
inline ::gnuradar::RadarParameters* File::release_radarparameters() {
  clear_has_radarparameters();
  ::gnuradar::RadarParameters* temp = radarparameters_;
  radarparameters_ = NULL;
  return temp;
}
inline void File::set_allocated_radarparameters(::gnuradar::RadarParameters* radarparameters) {
  delete radarparameters_;
  radarparameters_ = radarparameters;
  if (radarparameters) {
    set_has_radarparameters();
  } else {
    clear_has_radarparameters();
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.File.radarParameters)
}

// -------------------------------------------------------------------

// Channel

// required float frequency = 1;
inline bool Channel::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline float Channel::frequency() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.frequency)
  return frequency_;
}
inline void Channel::set_frequency(float value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Channel.frequency)
}

// required string frequencyUnits = 2;
inline bool Channel::has_frequencyunits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::set_has_frequencyunits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel::clear_has_frequencyunits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel::clear_frequencyunits() {
  if (frequencyunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frequencyunits_->clear();
  }
  clear_has_frequencyunits();
}
inline const ::std::string& Channel::frequencyunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.frequencyUnits)
  return *frequencyunits_;
}
inline void Channel::set_frequencyunits(const ::std::string& value) {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frequencyunits_ = new ::std::string;
  }
  frequencyunits_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.Channel.frequencyUnits)
}
inline void Channel::set_frequencyunits(const char* value) {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frequencyunits_ = new ::std::string;
  }
  frequencyunits_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.Channel.frequencyUnits)
}
inline void Channel::set_frequencyunits(const char* value, size_t size) {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frequencyunits_ = new ::std::string;
  }
  frequencyunits_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Channel.frequencyUnits)
}
inline ::std::string* Channel::mutable_frequencyunits() {
  set_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frequencyunits_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.Channel.frequencyUnits)
  return frequencyunits_;
}
inline ::std::string* Channel::release_frequencyunits() {
  clear_has_frequencyunits();
  if (frequencyunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = frequencyunits_;
    frequencyunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Channel::set_allocated_frequencyunits(::std::string* frequencyunits) {
  if (frequencyunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete frequencyunits_;
  }
  if (frequencyunits) {
    set_has_frequencyunits();
    frequencyunits_ = frequencyunits;
  } else {
    clear_has_frequencyunits();
    frequencyunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Channel.frequencyUnits)
}

// required float phase = 3;
inline bool Channel::has_phase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Channel::set_has_phase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Channel::clear_has_phase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Channel::clear_phase() {
  phase_ = 0;
  clear_has_phase();
}
inline float Channel::phase() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.phase)
  return phase_;
}
inline void Channel::set_phase(float value) {
  set_has_phase();
  phase_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Channel.phase)
}

// required string phaseUnits = 4;
inline bool Channel::has_phaseunits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Channel::set_has_phaseunits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Channel::clear_has_phaseunits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Channel::clear_phaseunits() {
  if (phaseunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phaseunits_->clear();
  }
  clear_has_phaseunits();
}
inline const ::std::string& Channel::phaseunits() const {
  // @@protoc_insertion_point(field_get:gnuradar.Channel.phaseUnits)
  return *phaseunits_;
}
inline void Channel::set_phaseunits(const ::std::string& value) {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phaseunits_ = new ::std::string;
  }
  phaseunits_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.Channel.phaseUnits)
}
inline void Channel::set_phaseunits(const char* value) {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phaseunits_ = new ::std::string;
  }
  phaseunits_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.Channel.phaseUnits)
}
inline void Channel::set_phaseunits(const char* value, size_t size) {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phaseunits_ = new ::std::string;
  }
  phaseunits_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Channel.phaseUnits)
}
inline ::std::string* Channel::mutable_phaseunits() {
  set_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phaseunits_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.Channel.phaseUnits)
  return phaseunits_;
}
inline ::std::string* Channel::release_phaseunits() {
  clear_has_phaseunits();
  if (phaseunits_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phaseunits_;
    phaseunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Channel::set_allocated_phaseunits(::std::string* phaseunits) {
  if (phaseunits_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phaseunits_;
  }
  if (phaseunits) {
    set_has_phaseunits();
    phaseunits_ = phaseunits;
  } else {
    clear_has_phaseunits();
    phaseunits_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Channel.phaseUnits)
}

// -------------------------------------------------------------------

// Window

// required string name = 1;
inline bool Window::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Window::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Window::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Window::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Window::name() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.name)
  return *name_;
}
inline void Window::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.Window.name)
}
inline void Window::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.Window.name)
}
inline void Window::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Window.name)
}
inline ::std::string* Window::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.Window.name)
  return name_;
}
inline ::std::string* Window::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Window::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Window.name)
}

// required float start = 2;
inline bool Window::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Window::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Window::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Window::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline float Window::start() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.start)
  return start_;
}
inline void Window::set_start(float value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Window.start)
}

// required float stop = 3;
inline bool Window::has_stop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Window::set_has_stop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Window::clear_has_stop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Window::clear_stop() {
  stop_ = 0;
  clear_has_stop();
}
inline float Window::stop() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.stop)
  return stop_;
}
inline void Window::set_stop(float value) {
  set_has_stop();
  stop_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Window.stop)
}

// optional float width = 4;
inline bool Window::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Window::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Window::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Window::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Window::width() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.width)
  return width_;
}
inline void Window::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.Window.width)
}

// required string units = 5;
inline bool Window::has_units() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Window::set_has_units() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Window::clear_has_units() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Window::clear_units() {
  if (units_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& Window::units() const {
  // @@protoc_insertion_point(field_get:gnuradar.Window.units)
  return *units_;
}
inline void Window::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  units_->assign(value);
  // @@protoc_insertion_point(field_set:gnuradar.Window.units)
}
inline void Window::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  units_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnuradar.Window.units)
}
inline void Window::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnuradar.Window.units)
}
inline ::std::string* Window::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    units_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnuradar.Window.units)
  return units_;
}
inline ::std::string* Window::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Window::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnuradar.Window.units)
}

// -------------------------------------------------------------------

// RadarParameters

// required int32 samplesPerPri = 1;
inline bool RadarParameters::has_samplesperpri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadarParameters::set_has_samplesperpri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadarParameters::clear_has_samplesperpri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadarParameters::clear_samplesperpri() {
  samplesperpri_ = 0;
  clear_has_samplesperpri();
}
inline ::google::protobuf::int32 RadarParameters::samplesperpri() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.samplesPerPri)
  return samplesperpri_;
}
inline void RadarParameters::set_samplesperpri(::google::protobuf::int32 value) {
  set_has_samplesperpri();
  samplesperpri_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.samplesPerPri)
}

// required int32 samplesPerBuffer = 2;
inline bool RadarParameters::has_samplesperbuffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadarParameters::set_has_samplesperbuffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadarParameters::clear_has_samplesperbuffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadarParameters::clear_samplesperbuffer() {
  samplesperbuffer_ = 0;
  clear_has_samplesperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::samplesperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.samplesPerBuffer)
  return samplesperbuffer_;
}
inline void RadarParameters::set_samplesperbuffer(::google::protobuf::int32 value) {
  set_has_samplesperbuffer();
  samplesperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.samplesPerBuffer)
}

// required int32 bytesPerBuffer = 3;
inline bool RadarParameters::has_bytesperbuffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadarParameters::set_has_bytesperbuffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadarParameters::clear_has_bytesperbuffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadarParameters::clear_bytesperbuffer() {
  bytesperbuffer_ = 0;
  clear_has_bytesperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::bytesperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.bytesPerBuffer)
  return bytesperbuffer_;
}
inline void RadarParameters::set_bytesperbuffer(::google::protobuf::int32 value) {
  set_has_bytesperbuffer();
  bytesperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.bytesPerBuffer)
}

// required float bytesPerSecond = 4;
inline bool RadarParameters::has_bytespersecond() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadarParameters::set_has_bytespersecond() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadarParameters::clear_has_bytespersecond() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadarParameters::clear_bytespersecond() {
  bytespersecond_ = 0;
  clear_has_bytespersecond();
}
inline float RadarParameters::bytespersecond() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.bytesPerSecond)
  return bytespersecond_;
}
inline void RadarParameters::set_bytespersecond(float value) {
  set_has_bytespersecond();
  bytespersecond_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.bytesPerSecond)
}

// required float pri = 5;
inline bool RadarParameters::has_pri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadarParameters::set_has_pri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadarParameters::clear_has_pri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadarParameters::clear_pri() {
  pri_ = 0;
  clear_has_pri();
}
inline float RadarParameters::pri() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.pri)
  return pri_;
}
inline void RadarParameters::set_pri(float value) {
  set_has_pri();
  pri_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.pri)
}

// required float prf = 6;
inline bool RadarParameters::has_prf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadarParameters::set_has_prf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadarParameters::clear_has_prf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadarParameters::clear_prf() {
  prf_ = 0;
  clear_has_prf();
}
inline float RadarParameters::prf() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.prf)
  return prf_;
}
inline void RadarParameters::set_prf(float value) {
  set_has_prf();
  prf_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.prf)
}

// required int32 prisPerBuffer = 7;
inline bool RadarParameters::has_prisperbuffer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RadarParameters::set_has_prisperbuffer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RadarParameters::clear_has_prisperbuffer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RadarParameters::clear_prisperbuffer() {
  prisperbuffer_ = 0;
  clear_has_prisperbuffer();
}
inline ::google::protobuf::int32 RadarParameters::prisperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.prisPerBuffer)
  return prisperbuffer_;
}
inline void RadarParameters::set_prisperbuffer(::google::protobuf::int32 value) {
  set_has_prisperbuffer();
  prisperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.prisPerBuffer)
}

// required int32 bytesPerSample = 8;
inline bool RadarParameters::has_bytespersample() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RadarParameters::set_has_bytespersample() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RadarParameters::clear_has_bytespersample() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RadarParameters::clear_bytespersample() {
  bytespersample_ = 0;
  clear_has_bytespersample();
}
inline ::google::protobuf::int32 RadarParameters::bytespersample() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.bytesPerSample)
  return bytespersample_;
}
inline void RadarParameters::set_bytespersample(::google::protobuf::int32 value) {
  set_has_bytespersample();
  bytespersample_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.bytesPerSample)
}

// required float secondsPerBuffer = 9;
inline bool RadarParameters::has_secondsperbuffer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RadarParameters::set_has_secondsperbuffer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RadarParameters::clear_has_secondsperbuffer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RadarParameters::clear_secondsperbuffer() {
  secondsperbuffer_ = 0;
  clear_has_secondsperbuffer();
}
inline float RadarParameters::secondsperbuffer() const {
  // @@protoc_insertion_point(field_get:gnuradar.RadarParameters.secondsPerBuffer)
  return secondsperbuffer_;
}
inline void RadarParameters::set_secondsperbuffer(float value) {
  set_has_secondsperbuffer();
  secondsperbuffer_ = value;
  // @@protoc_insertion_point(field_set:gnuradar.RadarParameters.secondsPerBuffer)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gnuradar

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Control_2eproto__INCLUDED
